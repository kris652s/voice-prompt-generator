 <!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Voice → Prompt → LLM</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body   { max-width: 820px; margin: 28px auto; padding: 0 16px; }
    h1     { margin: 0 0 8px; }
    p,h3   { margin: 10px 0; }
    button { padding: 10px 16px; font-size: 16px; cursor: pointer; }
    input[type="range"] { vertical-align: middle; width: 220px; }
    #status { margin: 8px 0; opacity: .8; min-height: 22px; }
    .box { white-space: pre-wrap; border: 1px solid #ddd; padding: 12px; border-radius: 10px; margin-top: 10px; background: #fafafa; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .muted { opacity: .8; font-size: 14px; }
    .ok { color: #276749; }
    .err { color: #b83280; }
  </style>
</head>
<body>
  <h1>Voice → Prompt → LLM</h1>
  <p class="muted">Click and speak. Recording stops automatically after your chosen duration.</p>

  <div class="row" style="margin-bottom:8px">
    <button id="recordBtn">Start Recording</button>
    <button id="stopBtn" disabled>Stop</button>
    <label>
      Duration:
      <strong><span id="secs">5</span>s</strong>
    </label>
    <input id="dur" type="range" min="3" max="20" value="5">
    <span id="countdown" class="muted"></span>
  </div>

  <div id="status"></div>

  <h3>Refined Prompt</h3>
  <div id="refined" class="box"></div>

  <h3>LLM Response</h3>
  <div id="result" class="box"></div>

  <script>
    const recordBtn  = document.getElementById('recordBtn');
    const stopBtn    = document.getElementById('stopBtn');
    const dur        = document.getElementById('dur');
    const secs       = document.getElementById('secs');
    const statusEl   = document.getElementById('status');
    const refinedEl  = document.getElementById('refined');
    const resultEl   = document.getElementById('result');
    const countdown  = document.getElementById('countdown');

    let mediaRecorder, chunks = [], stream, timer, countdownTick;

    // show current slider value
    dur.addEventListener('input', () => secs.textContent = dur.value);
    secs.textContent = dur.value;

    function setStatus(msg, ok=false, error=false) {
      statusEl.textContent = msg || '';
      statusEl.className = ok ? 'ok' : (error ? 'err' : '');
    }

    function supportsMime() {
      if (!window.MediaRecorder) return '';
      if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) return 'audio/webm;codecs=opus';
      if (MediaRecorder.isTypeSupported('audio/webm')) return 'audio/webm';
      return ''; // fallback not implemented; most Chromium/Firefox support webm.
    }

    async function startRecording() {
      try {
        const mimeType = supportsMime();
        if (!mimeType) {
          setStatus('Your browser does not support audio/webm recording. Try Chrome or Edge.', false, true);
          return;
        }

        chunks = [];
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream, { mimeType });

        mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) chunks.push(e.data); };

        mediaRecorder.onstop = async () => {
          // stop countdown & mic
          if (countdownTick) clearInterval(countdownTick);
          countdown.textContent = '';
          if (stream) stream.getTracks().forEach(t => t.stop());

          // send to backend
          const blob = new Blob(chunks, { type: 'audio/webm' });
          const form = new FormData();
          form.append('audio', blob, 'audio.webm');

          setStatus('Processing…');
          refinedEl.textContent = '';
          resultEl.textContent = '';

          try {
            const res = await fetch('/process-voice', { method: 'POST', body: form });
            const data = await res.json();

            if (data.error) {
              resultEl.textContent = 'Error: ' + data.error;
              setStatus('Finished with error', false, true);
            } else {
              refinedEl.textContent = data.refined_prompt || '(n/a)';
              resultEl.textContent = data.response || '';
              setStatus('Done', true, false);
            }
          } catch (err) {
            resultEl.textContent = 'Network error: ' + err.message;
            setStatus('Network error', false, true);
          } finally {
            recordBtn.disabled = false;
            stopBtn.disabled = true;
          }
        };

        // start recording
        mediaRecorder.start();
        recordBtn.disabled = true;
        stopBtn.disabled = false;
        const seconds = parseInt(dur.value, 10);
        let remain = seconds;
        countdown.textContent = `(${remain}s)`;
        countdownTick = setInterval(() => {
          remain -= 1;
          countdown.textContent = remain > 0 ? `(${remain}s)` : '';
          if (remain <= 0) { clearInterval(countdownTick); }
        }, 1000);

        setStatus(`Recording ${seconds}s…`);
        timer = setTimeout(stopRecording, seconds * 1000);
      } catch (e) {
        setStatus('Mic permission denied or not available: ' + e.message, false, true);
      }
    }

    function stopRecording() {
      if (timer) clearTimeout(timer);
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
      }
    }

    recordBtn.addEventListener('click', startRecording);
    stopBtn.addEventListener('click', () => {
      stopBtn.disabled = true;
      stopRecording();
      setStatus('Stopping…');
    });
  </script>
</body>
</html>
