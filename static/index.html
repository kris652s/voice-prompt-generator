 <!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Voice → Prompt → LLM</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body   { max-width: 820px; margin: 28px auto; padding: 0 16px; }
    h1     { margin: 0 0 8px; }
    p,h3   { margin: 10px 0; }
    button { padding: 10px 16px; font-size: 16px; cursor: pointer; }
    input[type="range"] { vertical-align: middle; width: 220px; }
    select { padding: 6px 10px; font-size: 14px; }
    label  { margin-right: 6px; }
    #status { margin: 8px 0; opacity: .85; min-height: 22px; }
    .box { white-space: pre-wrap; border: 1px solid #ddd; padding: 12px; border-radius: 10px; margin-top: 10px; background: #fafafa; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .muted { opacity: .8; font-size: 14px; }
    .ok { color: #276749; }
    .err { color: #b83280; }
  </style>
</head>
<body>
  <h1>Voice → Prompt → LLM</h1>
  <p class="muted">Click and speak. Recording stops automatically after your chosen duration.</p>

  <div class="row" style="margin-bottom:8px">
    <button id="recordBtn">Start Recording</button>
    <button id="stopBtn" disabled>Stop</button>

    <label>Duration: <strong><span id="secs">5</span>s</strong></label>
    <input id="dur" type="range" min="3" max="20" value="5">
    <span id="countdown" class="muted"></span>

    <label>Model:</label>
    <select id="model">
      <option value="gpt-4o-mini" selected>gpt-4o-mini (fast/cheap)</option>
      <option value="gpt-4o">gpt-4o (smarter)</option>
    </select>

    <label><input type="checkbox" id="streamToggle" checked> Stream response</label>
  </div>

  <div id="status"></div>

  <h3>Refined Prompt</h3>
  <div id="refined" class="box"></div>

  <h3>LLM Response</h3>
  <div id="result" class="box"></div>

  <script>
    const recordBtn  = document.getElementById('recordBtn');
    const stopBtn    = document.getElementById('stopBtn');
    const dur        = document.getElementById('dur');
    const secs       = document.getElementById('secs');
    const statusEl   = document.getElementById('status');
    const refinedEl  = document.getElementById('refined');
    const resultEl   = document.getElementById('result');
    const countdown  = document.getElementById('countdown');
    const modelSel   = document.getElementById('model');
    const streamToggle = document.getElementById('streamToggle');

    let mediaRecorder, chunks = [], stream, timer, countdownTick, chosenMime = '';

    dur.addEventListener('input', () => secs.textContent = dur.value);
    secs.textContent = dur.value;

    function setStatus(msg, ok=false, error=false) {
      statusEl.textContent = msg || '';
      statusEl.className = ok ? 'ok' : (error ? 'err' : '');
    }

    function pickMimeType() {
      if (!window.MediaRecorder) return '';
      if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) return 'audio/webm;codecs=opus';
      if (MediaRecorder.isTypeSupported('audio/webm')) return 'audio/webm';
      if (MediaRecorder.isTypeSupported('audio/mp4;codecs=mp4a.40.2')) return 'audio/mp4;codecs=mp4a.40.2';
      if (MediaRecorder.isTypeSupported('audio/mp4')) return 'audio/mp4';
      return '';
    }

    async function startRecording() {
      try {
        chosenMime = pickMimeType();
        if (!chosenMime) {
          setStatus('Your browser does not support in-browser audio recording. Try Chrome, Edge, or Safari 14+.', false, true);
          return;
        }

        chunks = [];
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream, { mimeType: chosenMime });

        mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) chunks.push(e.data); };

        mediaRecorder.onstop = async () => {
          if (countdownTick) clearInterval(countdownTick);
          countdown.textContent = '';
          if (stream) stream.getTracks().forEach(t => t.stop());

          const ext = chosenMime.startsWith('audio/mp4') ? 'mp4' : 'webm';
          const blob = new Blob(chunks, { type: chosenMime });
          const form = new FormData();
          form.append('audio', blob, `audio.${ext}`);
          form.append('mime', chosenMime);
          form.append('model', modelSel.value);

          refinedEl.textContent = '';
          resultEl.textContent  = '';
          setStatus('Processing…');

          try {
            if (streamToggle.checked) {
              // STREAMING: read the response body in chunks
              const res = await fetch('/process-voice-stream', { method: 'POST', body: form });
              if (!res.ok) {
                const txt = await res.text();
                resultEl.textContent = 'Error: ' + txt;
                setStatus('Finished with error', false, true);
                resetButtons();
                return;
              }
              // first line contains the refined prompt marker
              const reader = res.body.getReader();
              const dec = new TextDecoder();
              let buf = '';
              let first = true;

              while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                buf += dec.decode(value, { stream: true });

                // Process lines
                let idx;
                while ((idx = buf.indexOf('\n')) >= 0) {
                  const line = buf.slice(0, idx);
                  buf = buf.slice(idx + 1);

                  if (first && line.startsWith('__REFINED_PROMPT__:')) {
                    refinedEl.textContent = line.replace('__REFINED_PROMPT__:', '');
                    first = false;
                  } else {
                    resultEl.textContent += line;
                  }
                }
              }

              // flush any remaining text
              if (buf) {
                if (first && buf.startsWith('__REFINED_PROMPT__:')) {
                  refinedEl.textContent = buf.replace('__REFINED_PROMPT__:', '');
                } else {
                  resultEl.textContent += buf;
                }
              }

              setStatus('Done', true, false);
            } else {
              // NON-STREAM fallback
              const res = await fetch('/process-voice', { method: 'POST', body: form });
              const data = await res.json();
              if (data.error) {
                resultEl.textContent = 'Error: ' + data.error;
                setStatus('Finished with error', false, true);
              } else {
                refinedEl.textContent = data.refined_prompt || '(n/a)';
                resultEl.textContent  = data.response || '';
                setStatus('Done', true, false);
              }
            }
          } catch (err) {
            resultEl.textContent = 'Network error: ' + err.message;
            setStatus('Network error', false, true);
          } finally {
            resetButtons();
          }
        };

        mediaRecorder.start();
        recordBtn.disabled = true;
        stopBtn.disabled = false;
        const seconds = parseInt(dur.value, 10);
        let remain = seconds;
        countdown.textContent = `(${remain}s)`;
        const tick = () => {
          remain -= 1;
          countdown.textContent = remain > 0 ? `(${remain}s)` : '';
          if (remain <= 0) clearInterval(countdownTick);
        };
        countdownTick = setInterval(tick, 1000);

        setStatus(`Recording ${seconds}s…`);
        timer = setTimeout(stopRecording, seconds * 1000);
      } catch (e) {
        setStatus('Mic permission denied or not available: ' + e.message, false, true);
      }
    }

    function stopRecording() {
      if (timer) clearTimeout(timer);
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
      }
    }

    function resetButtons() {
      recordBtn.disabled = false;
      stopBtn.disabled = true;
    }

    recordBtn.addEventListener('click', startRecording);
    stopBtn.addEventListener('click', () => {
      stopBtn.disabled = true;
      stopRecording();
      setStatus('Stopping…');
    });
  </script>
</body>
</html>
